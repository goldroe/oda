tokens:

grouping:
( ) [ ] { }

unary:
+ - ! ~ & *

binary:
+ - | ^ << >>
* / % &
== != < <= >=
&&
||
? :

assign:
= := += -= |= ^= <<= >>= *= /= %=

literals:
IDENT  = [a-zA-Z][a-zA-z0-9_]*
FLOAT  = [0-9]*[.][0-9]+([eE][+-]?[0-9]+)?
INT    = [1-9][0-9]* | 0[xX][0-9a-fA-f]+ | 0[b][0-1]+ | 0[0-7]+
CHAR   = '\'' . '\''
STRING = '"' [^"]* '"'


example code:

struct Vector2 {
	int x;
	int y;
};

enum Flags {
	FLAG_NONE,
	FLAG_CONTINUE,
	FLAG_STALLED,
	FLAG_END
};

foo(a :int, b :bool = false) :int, Vector2 {
	n := a;

	if b {
		n += 10;
	}

	for x := 0; x < a; x++ {
		n++;
	}

	vec := Vector2{
		x = 10,
		y = 12
	};
	return n, vec;
}

factorial(x :int) :int {
	if x == 0 {
		return 1;
	}
	return x * fact(x - 1);
}

main(argc :int, argv :char**) :int {
	n := factorial(12); // comment fact
	x := 0.0;

	while n > 0 {
		++x;
	}

	return 0;
}

EBNF grammar:
Declarations:
var_decl = IDENT '=' expr
         | IDENT ':' type ('=' expr)?

basic_type = '[' ']'
           | '*'
type = IDENT basic_type*
type_list = type (',' type)*

enum_entry = IDENT 
enum_list = enum_entry (',' enum_entry)*
enum_decl = IDENT '{' enum_list? '}'

func_param = IDENT ':' type ('=' expr)? 
param_list = func_param (',' func_param)* 
func_decl = IDENT '(' param_list ')' ':' type_list stmt_block

aggregate_entry = IDENT ':' type ('=' expr)? ';'
aggregate_list = '{' aggregate_entry? '}'

decl = var_decl
	 | 'enum' enum_decl
	 | 'struct' aggregate_list
	 | 'union' aggregate_list
	 | func_decl

Statements:

for_op = IDENT '=' expr
       | IDENT '++'
	   | IDENT '--'
	   | '++' IDENT
	   | '--' IDENT

stmt_block = '{' stmt* '}'
stmt = 'return' expr ';'
     | 'if' expr stmt_block ('else' 'if' expr stmt_block)* ('else expr stmt_blocK)?
	 | 'while' expr stmt_block
	 | 'for' var_decl? (',' var_decl)* ';' expr ';' for_op stmt_block
